       def main

**
* Constants
*
map_width:
       equ  160
map_height:
       equ  256
coll_map_bank_height:
       equ  48
coll_map_bank:
       equ  >6004
coll_bank_base:
       equ  >6200

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base x 4
sprptb equ  >2000                      ; Sprite pattern table base
colrtb equ  >2b80                      ; Color table base
nametb equ  >2800                      ; Name table base x 2
spratb equ  >2b00                      ; Sprite attribute table base

**
* Scratch pad
*
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
plyrws equ  wrksp+>20                  ; Sound player work space
stack  equ  plyrws+>20
frame:
       equ  stack+>10
scroll_y:
       equ  frame+2

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm end_proc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

********************************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @graphics_mode
       bl   @init_vdp_ram
       clr  @scroll_y
*      Loop
loop:
       bl   @vsync
       bl   @update_screen
       inct @scroll_y
       jmp  loop

*********************************************************************
*
* Wait for vertical retrace
*
vsync:
       movb @vdpsta,r12
vsync_1:
       movb @vdpsta,r12
       jgt  vsync_1
       jeq  vsync_1
       b    *r11
*// vsync

*********************************************************************************
*
* Update screen
*
update_screen:
       .proc
*      Pattern table
       mov  @scroll_y,r0
       andi  r0,>0006
       srl  r0,1
       ori  r0,>0400
       bl   @vwtr
*      Name table
       li   r0,nametb
       mov  @scroll_y,r1
       srl  r1,3
       mov  @MS0,r2
       mpy  r2,r1
       mov  r2,r1
       ai   r1,MD0
       li   r3,24
       li   r4,vdpwd
update_screen_1:
       bl   @vwad
       mov  @MS0,r2
       srl  r2,2
update_screen_2:
       movb *r1+,*r4
       movb *r1+,*r4
       movb *r1+,*r4
       movb *r1+,*r4
       dec  r2
       jne  update_screen_2
       ai   r0,32
       dec  r3
       jne  update_screen_1
       .end_proc
*// update_screen

*********************************************************************************
*
* Get collision map value
*
* r0:  X coordinate
* r1:  Y coordinate
*
* Returns value in r0 MSB
*
* The ROM contains the collision map split into banks of 8K.
* Each bank contains 48 lines of 160 pixels of data ordered from top to bottom.
* Each pixel is represented by one byte, which determines the normal angle.
* The data start at bank offset coll_bank_offset = >200.
* The first bank is selected by writing to @coll_map_bank.
*
* Modifies r0-r2
*
get_coll_value:
       .proc
       mov  r1,r2                      ; Move y to LSW
       clr  r1                         ; Clear MSW
       div  @w_coll_map_bank_height,r1 ; Bank no in r1, line offset in r2
       sla  r1,1                       ; Convert to bank offset
       ai   r1,coll_map_bank           ; Add base offset
       seto *r1                        ; Select bank
       mov  r2,r1                      ; line offset
       mpy  @w_map_width,r1            ; Multiply line width and line offset
       a    r0,r2                      ; Add X
       ai   r2,coll_bank_base          ; Add ROM bank base address
       movb *r2,r0                     ; Get byte
       .end_proc
*// get_coll_value

*********************************************************************************
*
* Initialize
*
init_vdp_ram:
       .proc
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Patterns
       li   r0,ptrntb
       li   r1,VPFRM3
       mov  @TCHNUM,r2
       sla  r2,3
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,VPFRM2
       mov  @TCHNUM,r2
       sla  r2,3
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,VPFRM1
       mov  @TCHNUM,r2
       sla  r2,3
       bl   @vmbw
       li   r0,ptrntb+>1800
       li   r1,VPFRM0
       mov  @TCHNUM,r2
       sla  r2,3
       bl   @vmbw
*      Sprite patterns
       li   r0,sprptb
       li   r1,sprite_patterns
       li   r2,32
       bl   @vmbw
*      Colors
       li   r0,colrtb
       li   r1,>1f00
       li   r2,31
       bl   @vsmw
       li   r1,>0e00
       movb r1,@vdpwd
*      Name table
       li   r0,nametb
       li   r1,>ff00
       li   r2,>300
       bl   @vsmw
       .end_proc
*// init_vdp_ram

*********************************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vregs2
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       .end_proc
*      VDP registers
vregs2:
       byte >00                        ; Graphics I mode
       byte >c2                        ; 16K, display on, interrupt disabled
       byte nametb/>400                ; Name table
       byte colrtb/>40                 ; Color table
       byte ptrntb/>800                ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >0e                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr


*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       b    *r11
*// vsbw

*********************************************************************
*
* VDP Single byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: Byte to write in MSB
* R2: Number of bytes to write
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsmw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       dec  r2
       jne  vsmw_1
       b    *r11
*// vsmw

*********************************************************************
*
* VDP Multiple Bytes Write
*
* R0: Write address in VDP RAM
* R1: Source address in CPU RAM
* R2: Number of bytes to write
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vmbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_1:
       movb *r1+,@vdpwd                  ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       b    *r11
*// vmbw

***************************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       b    *r11
*      Quit
quit   clr  @>83c4                     ; Reset user ISR address
       blwp @>0000
*// check_quit

***************************************************************************
*
* Data
*
w_map_width:
       data map_width
w_map_height:
       data map_height
w_coll_map_bank_height:
       data coll_map_bank_height

sprite_patterns:
       data >071f, >3f77, >63f7, >ffff
       data >ffff, >7f7f, >3f1f, >0700
       data >c0f0, >f8fc, >fcfe, >fefe
       data >fefe, >fcfc, >f8f0, >c000

**
* Includes
*
normals:
       copy "normals.a99"
map:
       copy "map.a99"

       end
